/**
 * CVE Table Component
 * Displays CVE data with pagination and filtering
 */

'use client';

import React, { memo, useMemo, useCallback, useRef, useState, useEffect } from 'react';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { ChevronLeftIcon as ChevronLeft, ChevronRightIcon as ChevronRight, EyeIcon as Eye } from '@/components/icons';
import { useVirtualizer } from '@tanstack/react-virtual';

import type { CVEItem } from "@/lib/types";
import { createLogger } from "@/lib/logger";
import { useViewLearnMode } from '@/contexts/ViewLearnContext';
import { CVEDetailModal } from '@/components/cve-detail-modal';
import { getSeverityVariant, getSeverityLabel, getSeverityColorHex, getCVSSScore, getCVEDescription } from '@/lib/utils';

const logger = createLogger("cve-table");

interface CVETableProps {
  cves: CVEItem[];
  total: number;
  page: number;
  pageSize: number;
  isLoading: boolean;
  onPageChange: (page: number) => void;
  onPageSizeChange: (pageSize: number) => void;
  searchQuery?: string;
}

export const CVETable = memo(function CVETable({
  cves,
  total,
  page,
  pageSize,
  isLoading,
  onPageChange,
  onPageSizeChange,
  searchQuery,
}: CVETableProps) {
  const { mode } = useViewLearnMode();
  const isLearnMode = mode === 'learn';
 
  const [selected, setSelected] = useState<any>(null);
 
  // Memoized handler for row selection
  const handleRowSelect = useCallback((row: any) => {
    setSelected(row);
  }, []);
 
  // State for metric expand/collapse controls and copy confirmations
  const [expandedKeys, setExpandedKeys] = useState<Set<string>>(new Set());
  const [copiedKeys, setCopiedKeys] = useState<Set<string>>(new Set());
  const timersRef = useRef<Set<NodeJS.Timeout>>(new Set());
  
  // Cleanup timers on unmount
  useEffect(() => {
    return () => {
      timersRef.current.forEach(timer => clearTimeout(timer));
      timersRef.current.clear();
    };
  }, []);

  // Memoize pagination numbers to avoid recomputing on unrelated state updates
  const totalPages = useMemo(() => Math.max(1, Math.ceil(total / pageSize)), [total, pageSize]);
  const startIndex = useMemo(() => page * pageSize + 1, [page, pageSize, total]);
  const endIndex = useMemo(() => Math.min((page + 1) * pageSize, total), [page, pageSize, total]);

  // Apply local search filter to the currently loaded CVEs (server search not implemented)
  const filtered = useMemo(() => {
    if (!searchQuery) return cves;
    const q = searchQuery.trim().toLowerCase();
    if (!q) return cves;
    return cves.filter((c) => {
      const desc = (c.descriptions?.find(d => d.lang === 'en')?.value || '').toLowerCase();
      return c.id.toLowerCase().includes(q) || desc.includes(q);
    });
  }, [cves, searchQuery]);

  // Precompute derived row fields so rendering is cheaper
  const rows = useMemo(() => {
    return filtered.map((cve) => ({
      id: cve.id,
      score: getCVSSScore(cve),
      description: getCVEDescription(cve),
      published: cve.published ? new Date(cve.published).toLocaleDateString() : 'N/A',
      lastModified: cve.lastModified ? new Date(cve.lastModified).toLocaleDateString() : undefined,
      source: cve.sourceIdentifier || (cve as any).source || 'Unknown',
      status: cve.vulnStatus || 'Unknown',
      references: cve.references || [],
      weaknesses: cve.weaknesses || [],
      raw: cve,
    }));
  }, [filtered]);

  // Virtualization setup
  const parentRef = useRef<HTMLDivElement | null>(null);
  const rowVirtualizer = useVirtualizer({
    count: rows.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 80,
    overscan: 5,
  });

  const handlePrev = useCallback(() => {
    onPageChange(Math.max(0, page - 1));
  }, [onPageChange, page]);

  const handleNext = useCallback(() => {
    onPageChange(Math.min(totalPages - 1, page + 1));
  }, [onPageChange, page, totalPages]);

  // Clipboard helper (shows a brief copied confirmation)
  const handleCopy = useCallback(async (text: string, key: string) => {
    try {
      await navigator.clipboard.writeText(text);
      setCopiedKeys(prev => new Set(Array.from(prev).concat([key])));
      const timer = setTimeout(() => {
        setCopiedKeys(prev => {
          const next = new Set(prev);
          next.delete(key);
          return next;
        });
        timersRef.current.delete(timer);
      }, 2000);
      timersRef.current.add(timer);
    } catch (e) {
      logger.error('Clipboard copy failed', e, { textLength: text.length, key });
    }
  }, []);

  if (isLoading) {
    return (
      <div className="space-y-4">
        {[...Array(5)].map((_, i) => (
          <Skeleton key={i} className="h-20 w-full" />
        ))}
      </div>
    );
  }

  if (rows.length === 0) {
    return (
      <div className="text-center py-12">
        <p className="text-muted-foreground">No CVE records found</p>
        <p className="text-sm text-muted-foreground mt-2">
          Start a session to fetch CVE data from NVD
        </p>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      <div className="rounded-md border">
        {/* Header as grid to align with virtual rows */}
        <div className="hidden md:grid grid-cols-[140px_120px_1fr_120px_160px_120px_100px] gap-x-4 px-4 py-2 border-b text-sm font-medium text-muted-foreground">
          <div>CVE ID</div>
          <div>Severity</div>
          <div>Description</div>
          <div>Published</div>
          <div>Source</div>
          <div>Status</div>
          <div>Actions</div>
        </div>

        {/* Virtualized scroll area: only this element scrolls */}
        <div ref={parentRef} className="max-h-[56vh] overflow-auto">
          <div style={{ height: rowVirtualizer.getTotalSize(), position: 'relative' }}>
            {rowVirtualizer.getVirtualItems().map((virtualRow: any) => {
              const row = rows[virtualRow.index];
              const borderColor = getSeverityColorHex(row.score);
              return (
                <div
                  key={row.id}
                  role="row"
                  style={{
                    position: 'absolute',
                    top: virtualRow.start,
                    left: 0,
                    right: 0,
                    width: '100%',
                    borderLeft: `4px solid ${borderColor}`,
                  }}
                  className="grid grid-cols-[140px_120px_1fr_120px_160px_120px_100px] gap-x-4 items-center px-4 py-3 border-b bg-background z-10 hover:bg-muted/30"
                >
                  <div className="font-mono font-medium">{row.id}</div>
                  <div>
                    <div className="flex flex-col gap-1">
                      <Badge variant={getSeverityVariant(row.score)}>{getSeverityLabel(row.score)}</Badge>
                      {row.score !== undefined && (
                        <span className="text-xs text-muted-foreground">{row.score.toFixed(1)}</span>
                      )}
                    </div>
                  </div>
                  <div className="max-w-md">
                    <p className="text-sm line-clamp-2">{row.description}</p>
                  </div>
                  <div className="text-sm text-muted-foreground">{row.published}</div>
                  <div className="text-sm">{row.source}</div>
                  <div className="text-sm">
                    <span className="inline-block align-middle">{row.status}</span>
                  </div>
                   <div>
                     <Button
                       type="button"
                       variant="ghost"
                       size="sm"
                       className="cursor-pointer"
                       aria-label={`View ${row.id} details`}
                       onClick={() => handleRowSelect(row.raw)}
                     >
                       <Eye className="h-4 w-4 mr-1" />
                       View
                     </Button>
                   </div>
                </div>
              );
            })}
          </div>
        </div>
      </div>

      {/* Pagination */}
      <div className="flex items-center justify-between">
        <p className="text-sm text-muted-foreground">
          Showing {startIndex} to {Math.min(endIndex, page * pageSize + rows.length)} of {total} results (showing {rows.length} on this page)
        </p>
        <div className="flex items-center gap-2">
          <Button 
            variant="outline" 
            size="sm" 
            onClick={handlePrev} 
            disabled={page === 0} 
            className="cursor-pointer"
            aria-label={`Go to previous page, current page ${page + 1}`}
          >
            <ChevronLeft className="h-4 w-4" />
            Previous
          </Button>
          <div className="text-sm">Page {page + 1} of {totalPages}</div>
          <Button 
            variant="outline" 
            size="sm" 
            onClick={handleNext} 
            disabled={page >= totalPages - 1} 
            className="cursor-pointer"
            aria-label={`Go to next page, current page ${page + 1}`}
          >
            Next
            <ChevronRight className="h-4 w-4" />
          </Button>
        </div>
      </div>

      {/* Modal for CVE details (structured view) */}
      {selected && <CVEDetailModal cve={selected} onClose={() => setSelected(null)} />}
    </div>
  );
});

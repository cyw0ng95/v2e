package main

import (
	"bytes"
	"context"
	"encoding/json"
	"os"
	"testing"
	"time"

	"github.com/cyw0ng95/v2e/pkg/cve"
	"github.com/cyw0ng95/v2e/pkg/cve/local"
	"github.com/cyw0ng95/v2e/pkg/proc/subprocess"
)

func TestRPCSaveCVEByID(t *testing.T) {
	// Create a temporary database for testing
	dbPath := "/tmp/test_cve_local_save.db"
	defer os.Remove(dbPath)

	db, err := local.NewDB(dbPath)
	if err != nil {
		t.Fatalf("Failed to create database: %v", err)
	}
	defer db.Close()

	// Create handler
	handler := createSaveCVEByIDHandler(db)

	// Create test CVE data
	testCVE := cve.CVEItem{
		ID:           "CVE-2021-TEST",
		SourceID:     "test@example.com",
		VulnStatus:   "Test",
		Descriptions: []cve.Description{{Lang: "en", Value: "Test CVE"}},
	}

	// Create request message
	payload, _ := json.Marshal(map[string]interface{}{
		"cve": testCVE,
	})

	msg := &subprocess.Message{
		Type:    subprocess.MessageTypeRequest,
		ID:      "RPCSaveCVEByID",
		Payload: payload,
	}

	// Call handler
	ctx := context.Background()
	resp, err := handler(ctx, msg)

	// Check results
	if err != nil {
		t.Fatalf("Handler returned error: %v", err)
	}

	if resp.Type != subprocess.MessageTypeResponse {
		t.Errorf("Expected response type, got %s", resp.Type)
	}

	var result map[string]interface{}
	if err := json.Unmarshal(resp.Payload, &result); err != nil {
		t.Fatalf("Failed to unmarshal response: %v", err)
	}

	if !result["success"].(bool) {
		t.Error("Expected success=true")
	}

	if result["cve_id"] != "CVE-2021-TEST" {
		t.Errorf("Expected cve_id=CVE-2021-TEST, got %s", result["cve_id"])
	}

	// Verify CVE was saved
	saved, err := db.GetCVE("CVE-2021-TEST")
	if err != nil {
		t.Errorf("CVE was not saved: %v", err)
	}
	if saved.ID != "CVE-2021-TEST" {
		t.Errorf("Saved CVE ID mismatch: %s", saved.ID)
	}
}

func TestRPCIsCVEStoredByID(t *testing.T) {
	// Create a temporary database for testing
	dbPath := "/tmp/test_cve_local_check.db"
	defer os.Remove(dbPath)

	db, err := local.NewDB(dbPath)
	if err != nil {
		t.Fatalf("Failed to create database: %v", err)
	}
	defer db.Close()

	// Save a test CVE
	testCVE := &cve.CVEItem{
		ID:           "CVE-2021-EXISTS",
		SourceID:     "test@example.com",
		VulnStatus:   "Test",
		Descriptions: []cve.Description{{Lang: "en", Value: "Test CVE"}},
	}
	db.SaveCVE(testCVE)

	// Create handler
	handler := createIsCVEStoredByIDHandler(db)

	tests := []struct {
		name     string
		cveID    string
		expected bool
	}{
		{"Existing CVE", "CVE-2021-EXISTS", true},
		{"Non-existing CVE", "CVE-2021-NOTFOUND", false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create request message
			payload, _ := json.Marshal(map[string]string{
				"cve_id": tt.cveID,
			})

			msg := &subprocess.Message{
				Type:    subprocess.MessageTypeRequest,
				ID:      "RPCIsCVEStoredByID",
				Payload: payload,
			}

			// Call handler
			ctx := context.Background()
			resp, err := handler(ctx, msg)

			// Check results
			if err != nil {
				t.Fatalf("Handler returned error: %v", err)
			}

			if resp.Type != subprocess.MessageTypeResponse {
				t.Errorf("Expected response type, got %s", resp.Type)
			}

			var result map[string]interface{}
			if err := json.Unmarshal(resp.Payload, &result); err != nil {
				t.Fatalf("Failed to unmarshal response: %v", err)
			}

			if result["cve_id"] != tt.cveID {
				t.Errorf("Expected cve_id=%s, got %s", tt.cveID, result["cve_id"])
			}

			if result["stored"].(bool) != tt.expected {
				t.Errorf("Expected stored=%v, got %v", tt.expected, result["stored"])
			}
		})
	}
}

func TestCVELocalIntegration(t *testing.T) {
	// Skip in short mode
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	// Create a temporary database
	dbPath := "/tmp/test_cve_local_integration.db"
	defer os.Remove(dbPath)

	// Set environment variable
	os.Setenv("CVE_DB_PATH", dbPath)
	defer os.Unsetenv("CVE_DB_PATH")

	// Create subprocess
	sp := subprocess.New("cve-local-test")

	// Set up input/output buffers
	input := bytes.NewBuffer(nil)
	output := bytes.NewBuffer(nil)
	sp.SetInput(input)
	sp.SetOutput(output)

	// Start subprocess in background
	errChan := make(chan error, 1)
	go func() {
		errChan <- sp.Run()
	}()

	// Wait a bit for subprocess to start
	time.Sleep(100 * time.Millisecond)

	// Send a save request
	saveReq := map[string]interface{}{
		"type": "request",
		"id":   "RPCSaveCVEByID",
		"payload": map[string]interface{}{
			"cve": map[string]interface{}{
				"id":           "CVE-2021-INTTEST",
				"sourceIdentifier": "test@example.com",
				"vulnStatus":   "Test",
				"descriptions": []map[string]string{
					{"lang": "en", "value": "Integration test CVE"},
				},
			},
		},
	}

	reqJSON, _ := json.Marshal(saveReq)
	input.Write(reqJSON)
	input.Write([]byte("\n"))

	// Wait for response
	time.Sleep(500 * time.Millisecond)

	// Stop subprocess
	sp.Stop()

	// Check if there was an error
	select {
	case err := <-errChan:
		if err != nil && err != context.Canceled {
			t.Logf("Subprocess returned: %v", err)
		}
	default:
	}
}

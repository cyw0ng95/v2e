/*
Package main implements the cve-local RPC service.

RPC API Specification:

CVE Local Service
====================

Service Type: RPC (stdin/stdout message passing)
Description: Manages local storage and retrieval of CVE data using SQLite database.

	Provides CRUD operations for CVE records.

Available RPC Methods:
---------------------

 1. RPCSaveCVEByID
    Description: Saves a CVE record to the local database
    Request Parameters:
    - cve (object, required): CVE object to save (must include id field)
    Response:
    - success (bool): true if saved successfully
    - cve_id (string): ID of the saved CVE
    Errors:
    - Missing CVE data: cve parameter is required
    - Invalid CVE: CVE object is missing required fields
    - Database error: Failed to save to database
    Example:
    Request:  {"cve": {"id": "CVE-2021-44228", "descriptions": [...], ...}}
    Response: {"success": true, "cve_id": "CVE-2021-44228"}

 2. RPCIsCVEStoredByID
    Description: Checks if a CVE exists in the local database
    Request Parameters:
    - cve_id (string, required): CVE identifier to check
    Response:
    - exists (bool): true if CVE exists in database
    - cve_id (string): The queried CVE ID
    Errors:
    - Missing CVE ID: cve_id parameter is required
    - Database error: Failed to query database
    Example:
    Request:  {"cve_id": "CVE-2021-44228"}
    Response: {"exists": true, "cve_id": "CVE-2021-44228"}

 3. RPCGetCVEByID
    Description: Retrieves a CVE record from the local database
    Request Parameters:
    - cve_id (string, required): CVE identifier to retrieve
    Response:
    - cve (object): CVE object with all fields
    Errors:
    - Missing CVE ID: cve_id parameter is required
    - Not found: CVE not found in database
    - Database error: Failed to query database
    Example:
    Request:  {"cve_id": "CVE-2021-44228"}
    Response: {"cve": {"id": "CVE-2021-44228", "descriptions": [...], ...}}

 4. RPCDeleteCVEByID
    Description: Deletes a CVE record from the local database
    Request Parameters:
    - cve_id (string, required): CVE identifier to delete
    Response:
    - success (bool): true if deleted successfully
    - cve_id (string): ID of the deleted CVE
    Errors:
    - Missing CVE ID: cve_id parameter is required
    - Not found: CVE not found in database
    - Database error: Failed to delete from database
    Example:
    Request:  {"cve_id": "CVE-2021-44228"}
    Response: {"success": true, "cve_id": "CVE-2021-44228"}

 5. RPCListCVEs
    Description: Lists CVE records with pagination support
    Request Parameters:
    - offset (int, optional): Starting offset for pagination (default: 0)
    - limit (int, optional): Maximum number of records to return (default: 10)
    Response:
    - cves ([]object): Array of CVE objects
    - offset (int): Starting offset used
    - limit (int): Limit used
    - total (int): Total number of CVEs in database
    Errors:
    - Database error: Failed to query database
    Example:
    Request:  {"offset": 0, "limit": 10}
    Response: {"cves": [...], "offset": 0, "limit": 10, "total": 150}

 6. RPCCountCVEs
    Description: Gets the total count of CVEs in the local database
    Request Parameters: None
    Response:
    - count (int): Total number of CVE records
    Errors:
    - Database error: Failed to query database
    Example:
    Request:  {}
    Response: {"count": 150}

Notes:
------
- Uses SQLite database for local CVE storage
- Database path configured via CVE_DB_PATH environment variable (default: cve.db)
- Supports GORM for ORM operations
- Database schema includes indexes for efficient queries
- Service runs as a subprocess managed by the broker
- All requests are routed through the broker via RPC
*/
package main

import (
	"context"
	"fmt"
	"os"

	"github.com/bytedance/sonic"
	"github.com/cyw0ng95/v2e/pkg/common"
	"github.com/cyw0ng95/v2e/pkg/cve"
	"github.com/cyw0ng95/v2e/pkg/cve/local"
	"github.com/cyw0ng95/v2e/pkg/proc/subprocess"
)

func main() {
	// Get process ID from environment or use default
	processID := os.Getenv("PROCESS_ID")
	if processID == "" {
		processID = "cve-local"
	}

	// Set up logging using common subprocess framework
	logger, err := subprocess.SetupLogging(processID)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to setup logging: %v\n", err)
		os.Exit(1)
	}

	// Get database path from environment or use default
	dbPath := os.Getenv("CVE_DB_PATH")
	if dbPath == "" {
		dbPath = "cve.db"
	}

	// Create or open the database
	db, err := local.NewDB(dbPath)
	if err != nil {
		logger.Error("Failed to open database: %v", err)
		os.Exit(1)
	}
	defer db.Close()

	// Create subprocess instance
	sp := subprocess.New(processID)

	// Register RPC handlers
	sp.RegisterHandler("RPCSaveCVEByID", createSaveCVEByIDHandler(db, logger))
	sp.RegisterHandler("RPCIsCVEStoredByID", createIsCVEStoredByIDHandler(db, logger))
	sp.RegisterHandler("RPCGetCVEByID", createGetCVEByIDHandler(db, logger))
	sp.RegisterHandler("RPCDeleteCVEByID", createDeleteCVEByIDHandler(db, logger))
	sp.RegisterHandler("RPCListCVEs", createListCVEsHandler(db, logger))
	sp.RegisterHandler("RPCCountCVEs", createCountCVEsHandler(db, logger))

	logger.Info("CVE local service started")

	// Run with default lifecycle management
	subprocess.RunWithDefaults(sp, logger)
}

// createSaveCVEByIDHandler creates a handler for RPCSaveCVEByID
func createSaveCVEByIDHandler(db *local.DB, logger *common.Logger) subprocess.Handler {
	return func(ctx context.Context, msg *subprocess.Message) (*subprocess.Message, error) {
		// Parse the request payload
		var req struct {
			CVE cve.CVEItem `json:"cve"`
		}
		if err := subprocess.UnmarshalPayload(msg, &req); err != nil {
			logger.Error("Failed to parse request: %v", err)
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         fmt.Sprintf("failed to parse request: %v", err),
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}

		if req.CVE.ID == "" {
			logger.Error("cve.id is required")
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         "cve.id is required",
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}

		// Save CVE to database
		if err := db.SaveCVE(&req.CVE); err != nil {
			logger.Error("Failed to save CVE: %v", err)
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         fmt.Sprintf("failed to save CVE: %v", err),
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}

		logger.Info("Saved CVE %s to local database", req.CVE.ID)

		// Create response
		result := map[string]interface{}{
			"success": true,
			"cve_id":  req.CVE.ID,
		}

		// Create response message
		respMsg := &subprocess.Message{
			Type:          subprocess.MessageTypeResponse,
			ID:            msg.ID,
			CorrelationID: msg.CorrelationID,
			Target:        msg.Source,
		}

		// Marshal the result
		jsonData, err := sonic.Marshal(result)
		if err != nil {
			logger.Error("Failed to marshal result: %v", err)
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         fmt.Sprintf("failed to marshal result: %v", err),
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}
		respMsg.Payload = jsonData

		return respMsg, nil
	}
}

// createIsCVEStoredByIDHandler creates a handler for RPCIsCVEStoredByID
func createIsCVEStoredByIDHandler(db *local.DB, logger *common.Logger) subprocess.Handler {
	return func(ctx context.Context, msg *subprocess.Message) (*subprocess.Message, error) {
		// Parse the request payload
		var req struct {
			CVEID string `json:"cve_id"`
		}
		if err := subprocess.UnmarshalPayload(msg, &req); err != nil {
			logger.Error("Failed to parse request: %v", err)
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         fmt.Sprintf("failed to parse request: %v", err),
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}

		if req.CVEID == "" {
			logger.Error("cve_id is required")
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         "cve_id is required",
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}

		// Check if CVE exists in database
		_, err := db.GetCVE(req.CVEID)
		stored := err == nil

		logger.Debug("CVE %s stored status: %v", req.CVEID, stored)

		// Create response
		result := map[string]interface{}{
			"cve_id": req.CVEID,
			"stored": stored,
		}

		// Create response message
		respMsg := &subprocess.Message{
			Type:          subprocess.MessageTypeResponse,
			ID:            msg.ID,
			CorrelationID: msg.CorrelationID,
			Target:        msg.Source,
		}

		// Marshal the result
		jsonData, err := sonic.Marshal(result)
		if err != nil {
			logger.Error("Failed to marshal result: %v", err)
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         fmt.Sprintf("failed to marshal result: %v", err),
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}
		respMsg.Payload = jsonData

		return respMsg, nil
	}
}

// createGetCVEByIDHandler creates a handler for RPCGetCVEByID
func createGetCVEByIDHandler(db *local.DB, logger *common.Logger) subprocess.Handler {
	return func(ctx context.Context, msg *subprocess.Message) (*subprocess.Message, error) {
		// Parse the request payload
		var req struct {
			CVEID string `json:"cve_id"`
		}
		if err := subprocess.UnmarshalPayload(msg, &req); err != nil {
			logger.Error("Failed to parse request: %v", err)
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         fmt.Sprintf("failed to parse request: %v", err),
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}

		if req.CVEID == "" {
			logger.Error("cve_id is required")
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         "cve_id is required",
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}

		// Get CVE from database
		cveItem, err := db.GetCVE(req.CVEID)
		if err != nil {
			logger.Error("Failed to get CVE from database: %v", err)
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         fmt.Sprintf("CVE not found: %v", err),
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}

		logger.Info("Retrieved CVE %s from local database", req.CVEID)

		// Create response message
		respMsg := &subprocess.Message{
			Type:          subprocess.MessageTypeResponse,
			ID:            msg.ID,
			CorrelationID: msg.CorrelationID,
			Target:        msg.Source,
		}

		// Marshal the result
		jsonData, err := sonic.Marshal(cveItem)
		if err != nil {
			logger.Error("Failed to marshal result: %v", err)
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         fmt.Sprintf("failed to marshal result: %v", err),
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}
		respMsg.Payload = jsonData

		return respMsg, nil
	}
}

// createDeleteCVEByIDHandler creates a handler for RPCDeleteCVEByID
func createDeleteCVEByIDHandler(db *local.DB, logger *common.Logger) subprocess.Handler {
	return func(ctx context.Context, msg *subprocess.Message) (*subprocess.Message, error) {
		// Parse the request payload
		var req struct {
			CVEID string `json:"cve_id"`
		}
		if err := subprocess.UnmarshalPayload(msg, &req); err != nil {
			logger.Error("Failed to parse request: %v", err)
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         fmt.Sprintf("failed to parse request: %v", err),
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}

		if req.CVEID == "" {
			logger.Error("cve_id is required")
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         "cve_id is required",
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}

		// Delete CVE from database
		if err := db.DeleteCVE(req.CVEID); err != nil {
			logger.Error("Failed to delete CVE from database: %v", err)
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         fmt.Sprintf("failed to delete CVE: %v", err),
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}

		logger.Info("Deleted CVE %s from local database", req.CVEID)

		// Create response
		result := map[string]interface{}{
			"success": true,
			"cve_id":  req.CVEID,
		}

		// Create response message
		respMsg := &subprocess.Message{
			Type:          subprocess.MessageTypeResponse,
			ID:            msg.ID,
			CorrelationID: msg.CorrelationID,
			Target:        msg.Source,
		}

		// Marshal the result
		jsonData, err := sonic.Marshal(result)
		if err != nil {
			logger.Error("Failed to marshal result: %v", err)
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         fmt.Sprintf("failed to marshal result: %v", err),
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}
		respMsg.Payload = jsonData

		return respMsg, nil
	}
}

// createListCVEsHandler creates a handler for RPCListCVEs
func createListCVEsHandler(db *local.DB, logger *common.Logger) subprocess.Handler {
	return func(ctx context.Context, msg *subprocess.Message) (*subprocess.Message, error) {
		// Parse the request payload
		var req struct {
			Offset int `json:"offset"`
			Limit  int `json:"limit"`
		}

		// Set defaults
		req.Offset = 0
		req.Limit = 10

		// Try to parse payload, but use defaults if parsing fails
		if msg.Payload != nil {
			_ = subprocess.UnmarshalPayload(msg, &req)
		}

		logger.Debug("Listing CVEs with offset=%d, limit=%d", req.Offset, req.Limit)

		// List CVEs from database
		cves, err := db.ListCVEs(req.Offset, req.Limit)
		if err != nil {
			logger.Error("Failed to list CVEs from database: %v", err)
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         fmt.Sprintf("failed to list CVEs: %v", err),
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}

		// Get total count
		total, err := db.Count()
		if err != nil {
			logger.Error("Failed to get CVE count from database: %v", err)
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         fmt.Sprintf("failed to get CVE count: %v", err),
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}

		logger.Info("Listed %d CVEs (total: %d, offset: %d, limit: %d)", len(cves), total, req.Offset, req.Limit)

		// Create response
		result := map[string]interface{}{
			"cves":  cves,
			"total": total,
		}

		// Create response message
		respMsg := &subprocess.Message{
			Type:          subprocess.MessageTypeResponse,
			ID:            msg.ID,
			CorrelationID: msg.CorrelationID,
			Target:        msg.Source,
		}

		// Marshal the result
		jsonData, err := sonic.Marshal(result)
		if err != nil {
			logger.Error("Failed to marshal result: %v", err)
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         fmt.Sprintf("failed to marshal result: %v", err),
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}
		respMsg.Payload = jsonData

		return respMsg, nil
	}
}

// createCountCVEsHandler creates a handler for RPCCountCVEs
func createCountCVEsHandler(db *local.DB, logger *common.Logger) subprocess.Handler {
	return func(ctx context.Context, msg *subprocess.Message) (*subprocess.Message, error) {
		logger.Debug("Counting CVEs in database")

		// Get total count
		count, err := db.Count()
		if err != nil {
			logger.Error("Failed to count CVEs in database: %v", err)
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         fmt.Sprintf("failed to count CVEs: %v", err),
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}

		logger.Info("CVE count: %d", count)

		// Create response
		result := map[string]interface{}{
			"count": count,
		}

		// Create response message
		respMsg := &subprocess.Message{
			Type:          subprocess.MessageTypeResponse,
			ID:            msg.ID,
			CorrelationID: msg.CorrelationID,
			Target:        msg.Source,
		}

		// Marshal the result
		jsonData, err := sonic.Marshal(result)
		if err != nil {
			logger.Error("Failed to marshal result: %v", err)
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         fmt.Sprintf("failed to marshal result: %v", err),
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}
		respMsg.Payload = jsonData

		return respMsg, nil
	}
}

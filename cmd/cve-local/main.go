package main

import (
	"context"
	"github.com/bytedance/sonic"
	"fmt"
	"os"
	"os/signal"
	"syscall"

	"github.com/cyw0ng95/v2e/pkg/cve"
	"github.com/cyw0ng95/v2e/pkg/cve/local"
	"github.com/cyw0ng95/v2e/pkg/proc/subprocess"
)

func main() {
	// Get process ID from environment or use default
	processID := os.Getenv("PROCESS_ID")
	if processID == "" {
		processID = "cve-local"
	}

	// Set up logging using common subprocess logging
	if err := subprocess.SetupLogging(processID); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to setup logging: %v\n", err)
		os.Exit(1)
	}

	// Get database path from environment or use default
	dbPath := os.Getenv("CVE_DB_PATH")
	if dbPath == "" {
		dbPath = "cve.db"
	}

	// Create or open the database
	db, err := local.NewDB(dbPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to open database: %v\n", err)
		os.Exit(1)
	}
	defer db.Close()

	// Create subprocess instance
	sp := subprocess.New(processID)

	// Register RPC handlers
	sp.RegisterHandler("RPCSaveCVEByID", createSaveCVEByIDHandler(db))
	sp.RegisterHandler("RPCIsCVEStoredByID", createIsCVEStoredByIDHandler(db))

	// Set up signal handling for graceful shutdown
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

	// Run the subprocess in a goroutine
	errChan := make(chan error, 1)
	go func() {
		errChan <- sp.Run()
	}()

	// Wait for either completion or signal
	select {
	case err := <-errChan:
		if err != nil {
			sp.SendError("fatal", fmt.Errorf("subprocess error: %w", err))
			os.Exit(1)
		}
	case <-sigChan:
		sp.SendEvent("subprocess_shutdown", map[string]string{
			"id":     sp.ID,
			"reason": "signal received",
		})
		sp.Stop()
	}
}

// createSaveCVEByIDHandler creates a handler for RPCSaveCVEByID
func createSaveCVEByIDHandler(db *local.DB) subprocess.Handler {
	return func(ctx context.Context, msg *subprocess.Message) (*subprocess.Message, error) {
		// Parse the request payload
		var req struct {
			CVE cve.CVEItem `json:"cve"`
		}
		if err := subprocess.UnmarshalPayload(msg, &req); err != nil {
			return nil, fmt.Errorf("failed to parse request: %w", err)
		}

		if req.CVE.ID == "" {
			return nil, fmt.Errorf("cve.id is required")
		}

		// Save CVE to database
		if err := db.SaveCVE(&req.CVE); err != nil {
			return nil, fmt.Errorf("failed to save CVE: %w", err)
		}

		// Create response
		result := map[string]interface{}{
			"success": true,
			"cve_id":  req.CVE.ID,
		}

		// Create response message
		respMsg := &subprocess.Message{
			Type: subprocess.MessageTypeResponse,
			ID:   msg.ID,
		}

		// Marshal the result
		jsonData, err := sonic.Marshal(result)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal result: %w", err)
		}
		respMsg.Payload = jsonData

		return respMsg, nil
	}
}

// createIsCVEStoredByIDHandler creates a handler for RPCIsCVEStoredByID
func createIsCVEStoredByIDHandler(db *local.DB) subprocess.Handler {
	return func(ctx context.Context, msg *subprocess.Message) (*subprocess.Message, error) {
		// Parse the request payload
		var req struct {
			CVEID string `json:"cve_id"`
		}
		if err := subprocess.UnmarshalPayload(msg, &req); err != nil {
			return nil, fmt.Errorf("failed to parse request: %w", err)
		}

		if req.CVEID == "" {
			return nil, fmt.Errorf("cve_id is required")
		}

		// Check if CVE exists in database
		_, err := db.GetCVE(req.CVEID)
		stored := err == nil

		// Create response
		result := map[string]interface{}{
			"cve_id": req.CVEID,
			"stored": stored,
		}

		// Create response message
		respMsg := &subprocess.Message{
			Type: subprocess.MessageTypeResponse,
			ID:   msg.ID,
		}

		// Marshal the result
		jsonData, err := sonic.Marshal(result)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal result: %w", err)
		}
		respMsg.Payload = jsonData

		return respMsg, nil
	}
}

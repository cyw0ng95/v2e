/*
Package main implements the cve-remote RPC service.

RPC API Specification:

CVE Remote Service
====================

Service Type: RPC (stdin/stdout message passing)
Description: Fetches CVE (Common Vulnerabilities and Exposures) data from the NVD (National Vulnerability Database) API.
             Provides remote CVE data retrieval capabilities to other services.

Available RPC Methods:
---------------------

1. RPCGetCVEByID
   Description: Fetches a specific CVE by its ID from the NVD API
   Request Parameters:
     - cve_id (string, required): CVE identifier (e.g., "CVE-2021-44228")
   Response:
     - vulnerabilities ([]object): Array of vulnerability objects (typically one)
       Each vulnerability contains:
       - cve (object): CVE item with id, descriptions, metrics, references, etc.
   Errors:
     - Missing CVE ID: cve_id parameter is required
     - NVD API error: Failed to fetch from NVD API
     - Not found: CVE not found in NVD database
   Example:
     Request:  {"cve_id": "CVE-2021-44228"}
     Response: {"vulnerabilities": [{"cve": {"id": "CVE-2021-44228", "descriptions": [...], ...}}]}

2. RPCGetCVECnt
   Description: Gets the total count of CVEs available in the NVD database
   Request Parameters: None
   Response:
     - total_results (int): Total number of CVEs in NVD
   Errors:
     - NVD API error: Failed to query NVD API
   Example:
     Request:  {}
     Response: {"total_results": 234567}

3. RPCFetchCVEs
   Description: Fetches multiple CVEs with pagination support
   Request Parameters:
     - start_index (int, optional): Starting index for pagination (default: 0)
     - results_per_page (int, optional): Number of results per page (default: 100, max: 2000)
   Response:
     - vulnerabilities ([]object): Array of vulnerability objects
     - results_per_page (int): Requested results per page
     - start_index (int): Starting index used
     - total_results (int): Total CVEs available
   Errors:
     - NVD API error: Failed to fetch from NVD API
     - Rate limit: NVD API rate limit exceeded (HTTP 429)
   Example:
     Request:  {"start_index": 0, "results_per_page": 100}
     Response: {"vulnerabilities": [...], "results_per_page": 100, "start_index": 0, "total_results": 234567}

Notes:
------
- Uses NVD API v2.0 for CVE data retrieval
- Supports optional NVD_API_KEY environment variable for higher rate limits
- Without API key: 5 requests per 30 seconds
- With API key: 50 requests per 30 seconds
- Service runs as a subprocess managed by the broker
- All requests are routed through the broker via RPC

*/
package main

import (
	"context"
	"fmt"
	"os"

	"github.com/bytedance/sonic"
	"github.com/cyw0ng95/v2e/pkg/cve/remote"
	"github.com/cyw0ng95/v2e/pkg/proc/subprocess"
)

func main() {
	// Get process ID from environment or use default
	processID := os.Getenv("PROCESS_ID")
	if processID == "" {
		processID = "cve-remote"
	}

	// Set up logging using common subprocess framework
	logger, err := subprocess.SetupLogging(processID)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to setup logging: %v\n", err)
		os.Exit(1)
	}

	// Get API key from environment (optional)
	apiKey := os.Getenv("NVD_API_KEY")

	// Create CVE fetcher
	fetcher := remote.NewFetcher(apiKey)

	// Create subprocess instance
	sp := subprocess.New(processID)

	// Register RPC handlers
	sp.RegisterHandler("RPCGetCVEByID", createGetCVEByIDHandler(fetcher))
	sp.RegisterHandler("RPCGetCVECnt", createGetCVECntHandler(fetcher))
	sp.RegisterHandler("RPCFetchCVEs", createFetchCVEsHandler(fetcher))

	logger.Info("CVE remote service started")

	// Run with default lifecycle management
	subprocess.RunWithDefaults(sp, logger)
}

// createGetCVEByIDHandler creates a handler for RPCGetCVEByID
func createGetCVEByIDHandler(fetcher *remote.Fetcher) subprocess.Handler {
	return func(ctx context.Context, msg *subprocess.Message) (*subprocess.Message, error) {
		// Parse the request payload
		var req struct {
			CVEID string `json:"cve_id"`
		}
		if err := subprocess.UnmarshalPayload(msg, &req); err != nil {
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         fmt.Sprintf("failed to parse request: %v", err),
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}

		if req.CVEID == "" {
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         "cve_id is required",
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}

		// Fetch CVE from NVD
		response, err := fetcher.FetchCVEByID(req.CVEID)
		if err != nil {
			// Check if this is a rate limit error
			if err == remote.ErrRateLimited {
				return &subprocess.Message{
					Type:          subprocess.MessageTypeError,
					ID:            msg.ID,
					Error:         "NVD_RATE_LIMITED: NVD API rate limit exceeded (HTTP 429)",
					CorrelationID: msg.CorrelationID,
					Target:        msg.Source,
				}, nil
			}
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         fmt.Sprintf("failed to fetch CVE: %v", err),
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}

		// Create response
		respMsg := &subprocess.Message{
			Type:          subprocess.MessageTypeResponse,
			ID:            msg.ID,
			CorrelationID: msg.CorrelationID,
			Target:        msg.Source,
		}

		// Marshal the response
		jsonData, err := sonic.Marshal(response)
		if err != nil {
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         fmt.Sprintf("failed to marshal response: %v", err),
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}
		respMsg.Payload = jsonData

		return respMsg, nil
	}
}

// createGetCVECntHandler creates a handler for RPCGetCVECnt
func createGetCVECntHandler(fetcher *remote.Fetcher) subprocess.Handler {
	return func(ctx context.Context, msg *subprocess.Message) (*subprocess.Message, error) {
		// Parse the request payload (optional parameters)
		var req struct {
			StartIndex     int `json:"start_index"`
			ResultsPerPage int `json:"results_per_page"`
		}

		// Set defaults if not provided
		req.StartIndex = 0
		req.ResultsPerPage = 1 // Minimum to just get the count

		// Try to parse payload, but it's optional
		if msg.Payload != nil {
			_ = subprocess.UnmarshalPayload(msg, &req)
		}

		// Fetch CVEs to get the total count
		response, err := fetcher.FetchCVEs(req.StartIndex, req.ResultsPerPage)
		if err != nil {
			// Check if this is a rate limit error
			if err == remote.ErrRateLimited {
				return &subprocess.Message{
					Type:          subprocess.MessageTypeError,
					ID:            msg.ID,
					Error:         "NVD_RATE_LIMITED: NVD API rate limit exceeded (HTTP 429)",
					CorrelationID: msg.CorrelationID,
					Target:        msg.Source,
				}, nil
			}
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         fmt.Sprintf("failed to fetch CVE count: %v", err),
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}

		// Create response with count
		result := map[string]interface{}{
			"total_results": response.TotalResults,
		}

		// Create response message
		respMsg := &subprocess.Message{
			Type:          subprocess.MessageTypeResponse,
			ID:            msg.ID,
			CorrelationID: msg.CorrelationID,
			Target:        msg.Source,
		}

		// Marshal the result
		jsonData, err := sonic.Marshal(result)
		if err != nil {
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         fmt.Sprintf("failed to marshal result: %v", err),
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}
		respMsg.Payload = jsonData

		return respMsg, nil
	}
}

// createFetchCVEsHandler creates a handler for RPCFetchCVEs
func createFetchCVEsHandler(fetcher *remote.Fetcher) subprocess.Handler {
	return func(ctx context.Context, msg *subprocess.Message) (*subprocess.Message, error) {
		// Parse the request payload
		var req struct {
			StartIndex     int `json:"start_index"`
			ResultsPerPage int `json:"results_per_page"`
		}

		// Set defaults
		req.StartIndex = 0
		req.ResultsPerPage = 100

		// Try to parse payload
		if msg.Payload != nil {
			_ = subprocess.UnmarshalPayload(msg, &req)
		}

		// Fetch CVEs from NVD
		response, err := fetcher.FetchCVEs(req.StartIndex, req.ResultsPerPage)
		if err != nil {
			// Check if this is a rate limit error
			if err == remote.ErrRateLimited {
				return &subprocess.Message{
					Type:          subprocess.MessageTypeError,
					ID:            msg.ID,
					Error:         "NVD_RATE_LIMITED: NVD API rate limit exceeded (HTTP 429)",
					CorrelationID: msg.CorrelationID,
					Target:        msg.Source,
				}, nil
			}
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         fmt.Sprintf("failed to fetch CVEs: %v", err),
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}

		// Create response message
		respMsg := &subprocess.Message{
			Type:          subprocess.MessageTypeResponse,
			ID:            msg.ID,
			CorrelationID: msg.CorrelationID,
			Target:        msg.Source,
		}

		// Marshal the response
		jsonData, err := sonic.Marshal(response)
		if err != nil {
			return &subprocess.Message{
				Type:          subprocess.MessageTypeError,
				ID:            msg.ID,
				Error:         fmt.Sprintf("failed to marshal response: %v", err),
				CorrelationID: msg.CorrelationID,
				Target:        msg.Source,
			}, nil
		}
		respMsg.Payload = jsonData

		return respMsg, nil
	}
}

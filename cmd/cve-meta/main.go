package main

import (
"context"
"fmt"
"os"

"github.com/bytedance/sonic"
"github.com/cyw0ng95/v2e/pkg/cve"
"github.com/cyw0ng95/v2e/pkg/common"
"github.com/cyw0ng95/v2e/pkg/proc/subprocess"
)

func main() {
// Get process ID from environment or use default
processID := os.Getenv("PROCESS_ID")
if processID == "" {
processID = "cve-meta"
}

// Set up logging using common subprocess framework
logger, err := subprocess.SetupLogging(processID)
if err != nil {
fmt.Fprintf(os.Stderr, "Failed to setup logging: %v\n", err)
os.Exit(1)
}

// Create subprocess instance
sp := subprocess.New(processID)

// Register RPC handlers for orchestration
sp.RegisterHandler("RPCGetCVE", createGetCVEHandler(sp, logger))

logger.Info("CVE meta service started - orchestrates cve-local and cve-remote")

// Run with default lifecycle management
subprocess.RunWithDefaults(sp, logger)
}

// createGetCVEHandler creates a handler that orchestrates cve-local and cve-remote
// Note: This is a simplified implementation. Full implementation would require
// async request-response handling which is not yet implemented in the subprocess framework.
func createGetCVEHandler(sp *subprocess.Subprocess, logger *common.Logger) subprocess.Handler {
return func(ctx context.Context, msg *subprocess.Message) (*subprocess.Message, error) {
// Parse the request payload
var req struct {
CVEID string `json:"cve_id"`
}
if err := subprocess.UnmarshalPayload(msg, &req); err != nil {
return nil, fmt.Errorf("failed to parse request: %w", err)
}

if req.CVEID == "" {
return nil, fmt.Errorf("cve_id is required")
}

logger.Info("RPCGetCVE: Processing request for CVE %s", req.CVEID)
logger.Info("Note: Full cross-service RPC orchestration requires async request-response support")
logger.Info("Intended flow for CVE %s:", req.CVEID)
logger.Info("  1. Check cve-local for CVE existence")
logger.Info("  2. If not found locally, fetch from cve-remote (NVD API)")
logger.Info("  3. Save fetched CVE to cve-local database")
logger.Info("  4. Return CVE data to caller")

// Create a stub response for demonstration
stubCVE := &cve.CVEItem{
ID: req.CVEID,
Descriptions: []cve.Description{
{
Lang:  "en",
Value: "Stub CVE data - full cross-service orchestration pending async RPC support in subprocess framework",
},
},
}

// Create response message
respMsg := &subprocess.Message{
Type: subprocess.MessageTypeResponse,
ID:   msg.ID,
}

// Marshal the result
jsonData, err := sonic.Marshal(stubCVE)
if err != nil {
logger.Error("Failed to marshal response: %v", err)
return nil, fmt.Errorf("failed to marshal response: %w", err)
}
respMsg.Payload = jsonData

logger.Info("RPCGetCVE: Returning stub response for CVE %s", req.CVEID)
return respMsg, nil
}
}

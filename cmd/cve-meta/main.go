package main

import (
	"context"
	"fmt"
	"os"

	"github.com/bytedance/sonic"
	"github.com/cyw0ng95/v2e/pkg/common"
	"github.com/cyw0ng95/v2e/pkg/cve"
	"github.com/cyw0ng95/v2e/pkg/proc/subprocess"
)

func main() {
	// Get process ID from environment or use default
	processID := os.Getenv("PROCESS_ID")
	if processID == "" {
		processID = "cve-meta"
	}

	// Set up logging using common subprocess framework
	logger, err := subprocess.SetupLogging(processID)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to setup logging: %v\n", err)
		os.Exit(1)
	}

	// Create subprocess instance
	sp := subprocess.New(processID)

	// Register RPC handlers for orchestration
	sp.RegisterHandler("RPCGetCVE", createGetCVEHandler(sp, logger))

	logger.Info("CVE meta service started - orchestrates cve-local and cve-remote")

	// Run with default lifecycle management
	subprocess.RunWithDefaults(sp, logger)
}

// createErrorResponse creates a properly formatted error response message
func createErrorResponse(msg *subprocess.Message, errorMsg string) *subprocess.Message {
	return &subprocess.Message{
		Type:          subprocess.MessageTypeError,
		ID:            msg.ID,
		Error:         errorMsg,
		CorrelationID: msg.CorrelationID,
		Target:        msg.Source,
	}
}

// createGetCVEHandler creates a handler that orchestrates cve-local and cve-remote
// Note: This is a simplified implementation. Full implementation would require
// async request-response handling which is not yet implemented in the subprocess framework.
func createGetCVEHandler(sp *subprocess.Subprocess, logger *common.Logger) subprocess.Handler {
	return func(ctx context.Context, msg *subprocess.Message) (*subprocess.Message, error) {
		// Parse the request payload
		var req struct {
			CVEID string `json:"cve_id"`
		}
		if err := subprocess.UnmarshalPayload(msg, &req); err != nil {
			logger.Error("Failed to parse request: %v", err)
			return createErrorResponse(msg, fmt.Sprintf("failed to parse request: %v", err)), nil
		}

		if req.CVEID == "" {
			logger.Error("cve_id is required but was empty or missing")
			return createErrorResponse(msg, "cve_id is required"), nil
		}

		logger.Info("RPCGetCVE: Processing request for CVE %s", req.CVEID)
		logger.Info("Note: Full cross-service RPC orchestration requires async request-response support")
		logger.Info("Intended flow for CVE %s:", req.CVEID)
		logger.Info("  1. Check cve-local for CVE existence")
		logger.Info("  2. If not found locally, fetch from cve-remote (NVD API)")
		logger.Info("  3. Save fetched CVE to cve-local database")
		logger.Info("  4. Return CVE data to caller")

		// Create a stub response for demonstration
		stubCVE := &cve.CVEItem{
			ID: req.CVEID,
			Descriptions: []cve.Description{
				{
					Lang:  "en",
					Value: "Stub CVE data - full cross-service orchestration pending async RPC support in subprocess framework",
				},
			},
		}

		// Create response message
		respMsg := &subprocess.Message{
			Type:          subprocess.MessageTypeResponse,
			ID:            msg.ID,
			CorrelationID: msg.CorrelationID, // Preserve correlation ID for routing
			Target:        msg.Source,         // Set target to the source of the request
		}

		// Marshal the result
		jsonData, err := sonic.Marshal(stubCVE)
		if err != nil {
			logger.Error("Failed to marshal response: %v", err)
			return createErrorResponse(msg, fmt.Sprintf("failed to marshal response: %v", err)), nil
		}
		respMsg.Payload = jsonData

		logger.Info("RPCGetCVE: Returning stub response for CVE %s", req.CVEID)
		return respMsg, nil
	}
}

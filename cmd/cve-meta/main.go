package main

import (
	"context"
	"github.com/bytedance/sonic"
	"fmt"
	"io"
	"os"
	"os/signal"
	"path/filepath"
	"syscall"
	"time"

	"github.com/cyw0ng95/v2e/pkg/common"
	"github.com/cyw0ng95/v2e/pkg/proc"
	"github.com/cyw0ng95/v2e/pkg/proc/subprocess"
)

func main() {
	// Get process ID from environment or use default
	processID := os.Getenv("PROCESS_ID")
	if processID == "" {
		processID = "cve-meta"
	}

	// Get database path from environment or use default
	dbPath := os.Getenv("CVE_DB_PATH")
	if dbPath == "" {
		dbPath = "cve.db"
	}

	// Set up logger with stderr output
	logOutput := io.MultiWriter(os.Stderr)
	common.SetOutput(logOutput)
	common.SetLevel(common.InfoLevel)

	common.Info("[%s] Starting CVE meta service with database: %s", processID, dbPath)

	// Create subprocess instance
	sp := subprocess.New(processID)

	// Initialize the broker and spawn services
	broker, err := initializeServices(dbPath)
	if err != nil {
		common.Error("[%s] Failed to initialize services: %v", processID, err)
		sp.SendError("fatal", fmt.Errorf("failed to initialize services: %w", err))
		os.Exit(1)
	}
	defer broker.Shutdown()

	common.Info("[%s] Services initialized successfully", processID)

	// Register RPC handlers
	sp.RegisterHandler("RPCFetchAndStoreCVE", createFetchAndStoreCVEHandler(broker))
	sp.RegisterHandler("RPCBatchFetchCVEs", createBatchFetchCVEsHandler(broker))
	sp.RegisterHandler("RPCGetRemoteCVECount", createGetRemoteCVECountHandler(broker))

	// Set up signal handling for graceful shutdown
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

	// Run the subprocess in a goroutine
	errChan := make(chan error, 1)
	go func() {
		errChan <- sp.Run()
	}()

	// Wait for either completion or signal
	select {
	case err := <-errChan:
		if err != nil {
			common.Error("[%s] Subprocess error: %v", processID, err)
			sp.SendError("fatal", fmt.Errorf("subprocess error: %w", err))
			os.Exit(1)
		}
	case <-sigChan:
		common.Info("[%s] Received shutdown signal", processID)
		sp.SendEvent("subprocess_shutdown", map[string]string{
			"id":     sp.ID,
			"reason": "signal received",
		})
		sp.Stop()
	}

	common.Info("[%s] Shutdown complete", processID)
}

// findModuleRoot finds the Go module root directory by looking for go.mod
func findModuleRoot() (string, error) {
	dir, err := os.Getwd()
	if err != nil {
		return "", err
	}
	
	// Walk up the directory tree looking for go.mod
	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}
		
		parent := filepath.Dir(dir)
		if parent == dir {
			// Reached root without finding go.mod
			return "", fmt.Errorf("could not find go.mod in directory tree")
		}
		dir = parent
	}
}

// initializeServices spawns cve-local and cve-remote services
func initializeServices(dbPath string) (*proc.Broker, error) {
	// Create broker
	broker := proc.NewBroker()

	// Get the path to the built binaries
	exePath, err := os.Executable()
	if err != nil {
		return nil, fmt.Errorf("failed to get executable path: %w", err)
	}
	baseDir := filepath.Dir(exePath)

	// Find module root for go run paths
	moduleRoot, err := findModuleRoot()
	if err != nil {
		return nil, fmt.Errorf("failed to find module root: %w", err)
	}

	// Spawn CVE remote service
	cveRemotePath := filepath.Join(baseDir, "cve-remote")
	if _, err := os.Stat(cveRemotePath); os.IsNotExist(err) {
		cveRemotePath = "go"
		cveRemoteSource := filepath.Join(moduleRoot, "cmd", "cve-remote")
		_, err = broker.SpawnRPC("cve-remote", cveRemotePath, "run", cveRemoteSource)
	} else {
		_, err = broker.SpawnRPC("cve-remote", cveRemotePath)
	}
	if err != nil {
		return nil, fmt.Errorf("failed to spawn cve-remote: %w", err)
	}

	// Spawn CVE local service
	os.Setenv("CVE_DB_PATH", dbPath)
	cveLocalPath := filepath.Join(baseDir, "cve-local")
	if _, err := os.Stat(cveLocalPath); os.IsNotExist(err) {
		cveLocalPath = "go"
		cveLocalSource := filepath.Join(moduleRoot, "cmd", "cve-local")
		_, err = broker.SpawnRPC("cve-local", cveLocalPath, "run", cveLocalSource)
	} else {
		_, err = broker.SpawnRPC("cve-local", cveLocalPath)
	}
	if err != nil {
		return nil, fmt.Errorf("failed to spawn cve-local: %w", err)
	}

	// Wait for services to be ready by draining ready events
	// Use a longer timeout for go run which needs to compile first
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	readyCount := 0
	for readyCount < 2 {
		select {
		case <-ctx.Done():
			// Timeout - services did not become ready
			return nil, fmt.Errorf("timeout waiting for services to become ready (received %d/2 ready events)", readyCount)
		default:
			// Try to receive a message with short timeout
			msgCtx, msgCancel := context.WithTimeout(context.Background(), 500*time.Millisecond)
			msg, err := broker.ReceiveMessage(msgCtx)
			msgCancel()
			
			if err == nil && msg.Type == proc.MessageTypeEvent && msg.ID == "subprocess_ready" {
				readyCount++
			}
		}
	}

	return broker, nil
}

// createFetchAndStoreCVEHandler creates a handler for RPCFetchAndStoreCVE
// This handler fetches a CVE from remote (if not stored locally) and saves it
func createFetchAndStoreCVEHandler(broker *proc.Broker) subprocess.Handler {
	return func(ctx context.Context, msg *subprocess.Message) (*subprocess.Message, error) {
		// Parse the request payload
		var req struct {
			CVEID string `json:"cve_id"`
		}
		if err := subprocess.UnmarshalPayload(msg, &req); err != nil {
			return nil, fmt.Errorf("failed to parse request: %w", err)
		}

		if req.CVEID == "" {
			return nil, fmt.Errorf("cve_id is required")
		}

		// Step 1: Check if CVE is already stored locally
		checkMsg, _ := proc.NewRequestMessage("RPCIsCVEStoredByID", map[string]string{
			"cve_id": req.CVEID,
		})
		if err := broker.SendToProcess("cve-local", checkMsg); err != nil {
			return nil, fmt.Errorf("failed to send check message: %w", err)
		}

		// Wait for check response
		checkCtx, checkCancel := context.WithTimeout(ctx, 10*time.Second)
		defer checkCancel()

		var stored bool
		for {
			respMsg, err := broker.ReceiveMessage(checkCtx)
			if err != nil {
				return nil, fmt.Errorf("failed to receive check response: %w", err)
			}

			// Skip event messages and other non-matching responses
			if respMsg.Type == proc.MessageTypeEvent {
				continue
			}

			if respMsg.Type == proc.MessageTypeResponse && respMsg.ID == "RPCIsCVEStoredByID" {
				var resp map[string]interface{}
				if err := respMsg.UnmarshalPayload(&resp); err == nil {
					stored = resp["stored"].(bool)
				}
				break
			}
		}

		// If already stored, return success
		if stored {
			result := map[string]interface{}{
				"cve_id":        req.CVEID,
				"already_stored": true,
				"fetched":       false,
			}

			respMsg := &subprocess.Message{
				Type: subprocess.MessageTypeResponse,
				ID:   msg.ID,
			}
			jsonData, _ := sonic.Marshal(result)
			respMsg.Payload = jsonData
			return respMsg, nil
		}

		// Step 2: Fetch from remote
		fetchMsg, _ := proc.NewRequestMessage("RPCGetCVEByID", map[string]string{
			"cve_id": req.CVEID,
		})
		if err := broker.SendToProcess("cve-remote", fetchMsg); err != nil {
			return nil, fmt.Errorf("failed to send fetch message: %w", err)
		}

		// Wait for fetch response
		fetchCtx, fetchCancel := context.WithTimeout(ctx, 30*time.Second)
		defer fetchCancel()

		var cveData interface{}
		for {
			respMsg, err := broker.ReceiveMessage(fetchCtx)
			if err != nil {
				return nil, fmt.Errorf("failed to receive fetch response: %w", err)
			}

			// Skip event messages and other non-matching responses
			if respMsg.Type == proc.MessageTypeEvent {
				continue
			}

			if respMsg.Type == proc.MessageTypeResponse && respMsg.ID == "RPCGetCVEByID" {
				var resp map[string]interface{}
				if err := respMsg.UnmarshalPayload(&resp); err == nil {
					vulns := resp["vulnerabilities"].([]interface{})
					if len(vulns) > 0 {
						vuln := vulns[0].(map[string]interface{})
						cveData = vuln["cve"]
					}
				}
				break
			}
		}

		if cveData == nil {
			return nil, fmt.Errorf("no CVE data found for %s", req.CVEID)
		}

		// Step 3: Save to local database
		saveMsg, _ := proc.NewRequestMessage("RPCSaveCVEByID", map[string]interface{}{
			"cve": cveData,
		})
		if err := broker.SendToProcess("cve-local", saveMsg); err != nil {
			return nil, fmt.Errorf("failed to send save message: %w", err)
		}

		// Wait for save response
		saveCtx, saveCancel := context.WithTimeout(ctx, 10*time.Second)
		defer saveCancel()

		for {
			respMsg, err := broker.ReceiveMessage(saveCtx)
			if err != nil {
				return nil, fmt.Errorf("failed to receive save response: %w", err)
			}

			// Skip event messages and other non-matching responses
			if respMsg.Type == proc.MessageTypeEvent {
				continue
			}

			if respMsg.Type == proc.MessageTypeResponse && respMsg.ID == "RPCSaveCVEByID" {
				var resp map[string]interface{}
				if err := respMsg.UnmarshalPayload(&resp); err == nil {
					if !resp["success"].(bool) {
						return nil, fmt.Errorf("failed to save CVE to database")
					}
				}
				break
			}
		}

		// Create success response
		result := map[string]interface{}{
			"cve_id":        req.CVEID,
			"already_stored": false,
			"fetched":       true,
			"saved":         true,
		}

		respMsg := &subprocess.Message{
			Type: subprocess.MessageTypeResponse,
			ID:   msg.ID,
		}
		jsonData, _ := sonic.Marshal(result)
		respMsg.Payload = jsonData
		return respMsg, nil
	}
}

// createBatchFetchCVEsHandler creates a handler for RPCBatchFetchCVEs
// This handler fetches multiple CVEs by their IDs
func createBatchFetchCVEsHandler(broker *proc.Broker) subprocess.Handler {
	return func(ctx context.Context, msg *subprocess.Message) (*subprocess.Message, error) {
		// Parse the request payload
		var req struct {
			CVEIDs []string `json:"cve_ids"`
		}
		if err := subprocess.UnmarshalPayload(msg, &req); err != nil {
			return nil, fmt.Errorf("failed to parse request: %w", err)
		}

		if len(req.CVEIDs) == 0 {
			return nil, fmt.Errorf("cve_ids is required and must not be empty")
		}

		// Process each CVE ID
		results := make([]map[string]interface{}, 0, len(req.CVEIDs))
		for _, cveID := range req.CVEIDs {
			// Create a temporary message for this CVE
			tempMsg := &subprocess.Message{
				Type: subprocess.MessageTypeRequest,
				ID:   "temp-fetch-" + cveID,
			}
			payloadData, _ := sonic.Marshal(map[string]string{"cve_id": cveID})
			tempMsg.Payload = payloadData

			// Use the fetch handler
			handler := createFetchAndStoreCVEHandler(broker)
			resultMsg, err := handler(ctx, tempMsg)

			result := map[string]interface{}{
				"cve_id": cveID,
			}

			if err != nil {
				result["success"] = false
				result["error"] = err.Error()
			} else {
				var res map[string]interface{}
				if err := sonic.Unmarshal(resultMsg.Payload, &res); err == nil {
					result["success"] = true
					result["already_stored"] = res["already_stored"]
					result["fetched"] = res["fetched"]
					if saved, ok := res["saved"]; ok {
						result["saved"] = saved
					}
				}
			}

			results = append(results, result)
		}

		// Create response
		response := map[string]interface{}{
			"total":   len(req.CVEIDs),
			"results": results,
		}

		respMsg := &subprocess.Message{
			Type: subprocess.MessageTypeResponse,
			ID:   msg.ID,
		}
		jsonData, _ := sonic.Marshal(response)
		respMsg.Payload = jsonData
		return respMsg, nil
	}
}

// createGetRemoteCVECountHandler creates a handler for RPCGetRemoteCVECount
// This handler gets the total count of CVEs from the NVD API
func createGetRemoteCVECountHandler(broker *proc.Broker) subprocess.Handler {
	return func(ctx context.Context, msg *subprocess.Message) (*subprocess.Message, error) {
		// Send request to cve-remote
		cntMsg, _ := proc.NewRequestMessage("RPCGetCVECnt", map[string]interface{}{})
		if err := broker.SendToProcess("cve-remote", cntMsg); err != nil {
			return nil, fmt.Errorf("failed to send count request: %w", err)
		}

		// Wait for count response
		countCtx, countCancel := context.WithTimeout(ctx, 30*time.Second)
		defer countCancel()

		for {
			respMsg, err := broker.ReceiveMessage(countCtx)
			if err != nil {
				return nil, fmt.Errorf("failed to receive count response: %w", err)
			}

			// Skip event messages and other non-matching responses
			if respMsg.Type == proc.MessageTypeEvent {
				continue
			}

			if respMsg.Type == proc.MessageTypeResponse && respMsg.ID == "RPCGetCVECnt" {
				// Forward the response
				response := &subprocess.Message{
					Type:    subprocess.MessageTypeResponse,
					ID:      msg.ID,
					Payload: respMsg.Payload,
				}
				return response, nil
			}
		}
	}
}

package main

import (
	"context"
	"os"
	"path/filepath"
	"testing"

	"github.com/bytedance/sonic"
	"github.com/cyw0ng95/v2e/pkg/common"
	"github.com/cyw0ng95/v2e/pkg/cve/job"
	"github.com/cyw0ng95/v2e/pkg/cve/session"
	"github.com/cyw0ng95/v2e/pkg/proc/subprocess"
)

// mockRPCInvoker for benchmarking
type mockBenchRPCInvoker struct {
	fetchCalls int
	saveCalls  int
}

func (m *mockBenchRPCInvoker) InvokeRPC(ctx context.Context, target, method string, params interface{}) (interface{}, error) {
	if target == "cve-remote" && method == "RPCFetchCVEs" {
		m.fetchCalls++
		emptyPayload, _ := sonic.Marshal(map[string]interface{}{"vulnerabilities": []interface{}{}})
		return &subprocess.Message{Type: subprocess.MessageTypeResponse, Payload: emptyPayload}, nil
	}
	if target == "cve-local" && method == "RPCSaveCVEByID" {
		m.saveCalls++
		payload, _ := sonic.Marshal(map[string]interface{}{"success": true})
		return &subprocess.Message{Type: subprocess.MessageTypeResponse, Payload: payload}, nil
	}
	return nil, nil
}

// BenchmarkRPCStartSession benchmarks the RPCStartSession handler
func BenchmarkRPCStartSession(b *testing.B) {
	logger := common.NewLogger(os.Stderr, "bench", common.InfoLevel)
	dbPath := filepath.Join(b.TempDir(), "bench_rpc_start.db")

	sessionManager, err := session.NewManager(dbPath)
	if err != nil {
		b.Fatalf("Failed to create session manager: %v", err)
	}
	defer sessionManager.Close()

	mockRPC := &mockBenchRPCInvoker{}
	jobController := job.NewController(mockRPC, sessionManager, logger)

	handler := createStartSessionHandler(sessionManager, jobController, logger)

	ctx := context.Background()

	b.ReportAllocs()
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		b.StopTimer()
		sessionManager.DeleteSession()

		req := struct {
			SessionID       string `json:"session_id"`
			StartIndex      int    `json:"start_index"`
			ResultsPerBatch int    `json:"results_per_batch"`
		}{
			SessionID:       "bench-session",
			StartIndex:      0,
			ResultsPerBatch: 100,
		}
		payload, _ := sonic.Marshal(req)
		msg := &subprocess.Message{
			Type:    subprocess.MessageTypeRequest,
			ID:      "bench-1",
			Payload: payload,
		}
		b.StartTimer()

		resp, err := handler(ctx, msg)
		if err != nil {
			b.Fatalf("Handler failed: %v", err)
		}
		if resp == nil {
			b.Fatal("Response is nil")
		}

		b.StopTimer()
		jobController.Stop()
		b.StartTimer()
	}
}

// BenchmarkRPCGetSessionStatus benchmarks the RPCGetSessionStatus handler
func BenchmarkRPCGetSessionStatus(b *testing.B) {
	logger := common.NewLogger(os.Stderr, "bench", common.InfoLevel)
	dbPath := filepath.Join(b.TempDir(), "bench_rpc_status.db")

	sessionManager, err := session.NewManager(dbPath)
	if err != nil {
		b.Fatalf("Failed to create session manager: %v", err)
	}
	defer sessionManager.Close()

	// Create a session
	sessionManager.CreateSession("bench-session", 0, 100)

	handler := createGetSessionStatusHandler(sessionManager, logger)

	ctx := context.Background()
	msg := &subprocess.Message{
		Type: subprocess.MessageTypeRequest,
		ID:   "bench-1",
	}

	b.ReportAllocs()
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		resp, err := handler(ctx, msg)
		if err != nil {
			b.Fatalf("Handler failed: %v", err)
		}
		if resp == nil {
			b.Fatal("Response is nil")
		}
	}
}

// BenchmarkRPCStopSession benchmarks the RPCStopSession handler
func BenchmarkRPCStopSession(b *testing.B) {
	logger := common.NewLogger(os.Stderr, "bench", common.InfoLevel)
	dbPath := filepath.Join(b.TempDir(), "bench_rpc_stop.db")

	sessionManager, err := session.NewManager(dbPath)
	if err != nil {
		b.Fatalf("Failed to create session manager: %v", err)
	}
	defer sessionManager.Close()

	mockRPC := &mockBenchRPCInvoker{}
	jobController := job.NewController(mockRPC, sessionManager, logger)

	handler := createStopSessionHandler(sessionManager, jobController, logger)

	ctx := context.Background()
	msg := &subprocess.Message{
		Type: subprocess.MessageTypeRequest,
		ID:   "bench-1",
	}

	b.ReportAllocs()
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		b.StopTimer()
		sessionManager.CreateSession("bench-session", 0, 100)
		jobController.Start(ctx)
		b.StartTimer()

		resp, err := handler(ctx, msg)
		if err != nil {
			b.Fatalf("Handler failed: %v", err)
		}
		if resp == nil {
			b.Fatal("Response is nil")
		}
	}
}

// BenchmarkRPCPauseJob benchmarks the RPCPauseJob handler
func BenchmarkRPCPauseJob(b *testing.B) {
	logger := common.NewLogger(os.Stderr, "bench", common.InfoLevel)
	dbPath := filepath.Join(b.TempDir(), "bench_rpc_pause.db")

	sessionManager, err := session.NewManager(dbPath)
	if err != nil {
		b.Fatalf("Failed to create session manager: %v", err)
	}
	defer sessionManager.Close()

	sessionManager.CreateSession("bench-session", 0, 100)

	mockRPC := &mockBenchRPCInvoker{}
	jobController := job.NewController(mockRPC, sessionManager, logger)

	handler := createPauseJobHandler(jobController, logger)

	ctx := context.Background()
	msg := &subprocess.Message{
		Type: subprocess.MessageTypeRequest,
		ID:   "bench-1",
	}

	b.ReportAllocs()
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		b.StopTimer()
		if !jobController.IsRunning() {
			jobController.Resume(ctx)
		}
		b.StartTimer()

		resp, err := handler(ctx, msg)
		if err != nil {
			b.Fatalf("Handler failed: %v", err)
		}
		if resp == nil {
			b.Fatal("Response is nil")
		}
	}

	jobController.Stop()
}

// BenchmarkRPCResumeJob benchmarks the RPCResumeJob handler
func BenchmarkRPCResumeJob(b *testing.B) {
	logger := common.NewLogger(os.Stderr, "bench", common.InfoLevel)
	dbPath := filepath.Join(b.TempDir(), "bench_rpc_resume.db")

	sessionManager, err := session.NewManager(dbPath)
	if err != nil {
		b.Fatalf("Failed to create session manager: %v", err)
	}
	defer sessionManager.Close()

	sessionManager.CreateSession("bench-session", 0, 100)

	mockRPC := &mockBenchRPCInvoker{}
	jobController := job.NewController(mockRPC, sessionManager, logger)

	handler := createResumeJobHandler(jobController, logger)

	ctx := context.Background()
	msg := &subprocess.Message{
		Type: subprocess.MessageTypeRequest,
		ID:   "bench-1",
	}

	// Start and pause to get into paused state
	jobController.Start(ctx)
	jobController.Pause()

	b.ReportAllocs()
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		b.StopTimer()
		if jobController.IsRunning() {
			jobController.Pause()
		}
		b.StartTimer()

		resp, err := handler(ctx, msg)
		if err != nil {
			b.Fatalf("Handler failed: %v", err)
		}
		if resp == nil {
			b.Fatal("Response is nil")
		}
	}

	jobController.Stop()
}

// BenchmarkRPCMessageOverhead benchmarks the overhead of RPC message creation
func BenchmarkRPCMessageOverhead(b *testing.B) {
	data := map[string]interface{}{
		"session_id":        "bench-session",
		"state":             "running",
		"fetched_count":     1000,
		"stored_count":      950,
		"error_count":       50,
		"start_index":       0,
		"results_per_batch": 100,
	}

	b.ReportAllocs()
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		msg := &subprocess.Message{
			Type:          subprocess.MessageTypeResponse,
			ID:            "bench-1",
			CorrelationID: "bench-corr-1",
			Target:        "cve-meta",
		}

		payload, err := sonic.Marshal(data)
		if err != nil {
			b.Fatalf("Marshal failed: %v", err)
		}
		msg.Payload = payload
	}
}

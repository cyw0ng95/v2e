package main

import (
	"bytes"
	"context"
	"encoding/json"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/cyw0ng95/v2e/pkg/proc/subprocess"
)

// TestRPCFetchAndStoreCVE tests the RPCFetchAndStoreCVE handler
func TestRPCFetchAndStoreCVE(t *testing.T) {
	// Create a temporary database file
	tmpDir := t.TempDir()
	dbPath := filepath.Join(tmpDir, "test_cve.db")
	os.Setenv("CVE_DB_PATH", dbPath)
	defer os.Unsetenv("CVE_DB_PATH")

	// Create buffers for stdin/stdout
	stdin := bytes.NewBufferString("")
	stdout := bytes.NewBuffer(nil)

	// Create subprocess instance
	sp := subprocess.New("cve-meta-test")
	sp.SetInput(stdin)
	sp.SetOutput(stdout)

	// Initialize services
	broker, err := initializeServices(dbPath)
	if err != nil {
		t.Fatalf("Failed to initialize services: %v", err)
	}
	defer broker.Shutdown()

	// Register handlers
	sp.RegisterHandler("RPCFetchAndStoreCVE", createFetchAndStoreCVEHandler(broker))

	// Create request message
	req := &subprocess.Message{
		Type: subprocess.MessageTypeRequest,
		ID:   "RPCFetchAndStoreCVE",
	}
	reqPayload := map[string]string{
		"cve_id": "CVE-2021-44228",
	}
	payloadData, _ := json.Marshal(reqPayload)
	req.Payload = payloadData

	// Create a channel to capture the response
	responseChan := make(chan *subprocess.Message, 1)

	// Mock the Run loop - directly call the handler
	handler := createFetchAndStoreCVEHandler(broker)
	go func() {
		// Call handler with timeout context
		ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
		defer cancel()
		
		resp, err := handler(ctx, req)
		if err != nil {
			t.Errorf("Handler returned error: %v", err)
			return
		}
		responseChan <- resp
	}()

	// Wait for response with timeout
	select {
	case resp := <-responseChan:
		if resp.Type != subprocess.MessageTypeResponse {
			t.Errorf("Expected response message, got %s", resp.Type)
		}
		if resp.ID != "RPCFetchAndStoreCVE" {
			t.Errorf("Expected ID RPCFetchAndStoreCVE, got %s", resp.ID)
		}

		// Parse response
		var result map[string]interface{}
		if err := json.Unmarshal(resp.Payload, &result); err != nil {
			t.Fatalf("Failed to parse response: %v", err)
		}

		t.Logf("Response: %+v", result)

		// Verify response fields
		if result["cve_id"] != "CVE-2021-44228" {
			t.Errorf("Expected cve_id CVE-2021-44228, got %s", result["cve_id"])
		}

		// Either it was fetched or already stored
		if fetched, ok := result["fetched"].(bool); ok && fetched {
			t.Logf("Successfully fetched and stored CVE-2021-44228")
		} else if alreadyStored, ok := result["already_stored"].(bool); ok && alreadyStored {
			t.Logf("CVE-2021-44228 was already stored")
		} else {
			t.Errorf("Unexpected response state: %+v", result)
		}

	case <-time.After(70 * time.Second):
		t.Fatal("Timeout waiting for response")
	}
}

// TestRPCBatchFetchCVEs tests the RPCBatchFetchCVEs handler
func TestRPCBatchFetchCVEs(t *testing.T) {
	// Skip if this is a short test
	if testing.Short() {
		t.Skip("Skipping batch fetch test in short mode")
	}

	// Create a temporary database file
	tmpDir := t.TempDir()
	dbPath := filepath.Join(tmpDir, "test_batch_cve.db")
	os.Setenv("CVE_DB_PATH", dbPath)
	defer os.Unsetenv("CVE_DB_PATH")

	// Initialize services
	broker, err := initializeServices(dbPath)
	if err != nil {
		t.Fatalf("Failed to initialize services: %v", err)
	}
	defer broker.Shutdown()

	// Create request message for batch fetch
	req := &subprocess.Message{
		Type: subprocess.MessageTypeRequest,
		ID:   "RPCBatchFetchCVEs",
	}
	reqPayload := map[string]interface{}{
		"cve_ids": []string{"CVE-2021-44228", "CVE-2024-1234"},
	}
	payloadData, _ := json.Marshal(reqPayload)
	req.Payload = payloadData

	// Create a channel to capture the response
	responseChan := make(chan *subprocess.Message, 1)

	// Call handler
	handler := createBatchFetchCVEsHandler(broker)
	go func() {
		ctx, cancel := context.WithTimeout(context.Background(), 120*time.Second)
		defer cancel()
		
		resp, err := handler(ctx, req)
		if err != nil {
			t.Errorf("Handler returned error: %v", err)
			return
		}
		responseChan <- resp
	}()

	// Wait for response
	select {
	case resp := <-responseChan:
		if resp.Type != subprocess.MessageTypeResponse {
			t.Errorf("Expected response message, got %s", resp.Type)
		}

		// Parse response
		var result map[string]interface{}
		if err := json.Unmarshal(resp.Payload, &result); err != nil {
			t.Fatalf("Failed to parse response: %v", err)
		}

		t.Logf("Batch response: %+v", result)

		// Verify total
		if total, ok := result["total"].(float64); ok {
			if int(total) != 2 {
				t.Errorf("Expected total 2, got %d", int(total))
			}
		}

		// Verify results
		if results, ok := result["results"].([]interface{}); ok {
			t.Logf("Processed %d CVEs", len(results))
			for i, r := range results {
				resultMap := r.(map[string]interface{})
				t.Logf("CVE %d: %+v", i, resultMap)
			}
		}

	case <-time.After(130 * time.Second):
		t.Fatal("Timeout waiting for batch response")
	}
}

// TestRPCGetRemoteCVECount tests the RPCGetRemoteCVECount handler
func TestRPCGetRemoteCVECount(t *testing.T) {
	// Create a temporary database file
	tmpDir := t.TempDir()
	dbPath := filepath.Join(tmpDir, "test_count_cve.db")
	os.Setenv("CVE_DB_PATH", dbPath)
	defer os.Unsetenv("CVE_DB_PATH")

	// Initialize services
	broker, err := initializeServices(dbPath)
	if err != nil {
		t.Fatalf("Failed to initialize services: %v", err)
	}
	defer broker.Shutdown()

	// Check process status
	time.Sleep(3 * time.Second)
	processes := broker.ListProcesses()
	t.Logf("Active processes: %d", len(processes))
	for _, p := range processes {
		t.Logf("Process %s: PID=%d Status=%s", p.ID, p.PID, p.Status)
	}

	// Create request message
	req := &subprocess.Message{
		Type:    subprocess.MessageTypeRequest,
		ID:      "RPCGetRemoteCVECount",
		Payload: json.RawMessage("{}"),
	}

	// Create a channel to capture the response
	responseChan := make(chan *subprocess.Message, 1)

	// Call handler
	handler := createGetRemoteCVECountHandler(broker)
	go func() {
		ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
		defer cancel()
		
		resp, err := handler(ctx, req)
		if err != nil {
			t.Errorf("Handler returned error: %v", err)
			return
		}
		responseChan <- resp
	}()

	// Wait for response
	select {
	case resp := <-responseChan:
		if resp.Type != subprocess.MessageTypeResponse {
			t.Errorf("Expected response message, got %s", resp.Type)
		}

		// Parse response
		var result map[string]interface{}
		if err := json.Unmarshal(resp.Payload, &result); err != nil {
			t.Fatalf("Failed to parse response: %v", err)
		}

		t.Logf("Count response: %+v", result)

		// Verify total_results field exists and is > 0
		if totalResults, ok := result["total_results"].(float64); ok {
			if totalResults <= 0 {
				t.Errorf("Expected total_results > 0, got %f", totalResults)
			}
			t.Logf("Total CVEs in NVD: %d", int(totalResults))
		} else {
			t.Error("total_results field not found in response")
		}

	case <-time.After(70 * time.Second):
		t.Fatal("Timeout waiting for count response")
	}
}

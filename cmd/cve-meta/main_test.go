package main

import (
	"context"
	"os"
	"testing"
	"time"

	"github.com/bytedance/sonic"
	"github.com/cyw0ng95/v2e/pkg/common"
	"github.com/cyw0ng95/v2e/pkg/proc/subprocess"
)

// These tests focus on error handling and input validation
// Integration tests for full RPC flows are in the tests/ directory

func TestCreateErrorResponse(t *testing.T) {
	msg := &subprocess.Message{
		Type:          subprocess.MessageTypeRequest,
		ID:            "test-request",
		Source:        "test-source",
		CorrelationID: "test-correlation",
	}

	errMsg := createErrorResponse(msg, "test error")

	if errMsg.Type != subprocess.MessageTypeError {
		t.Errorf("Expected error type, got %s", errMsg.Type)
	}

	if errMsg.Error != "test error" {
		t.Errorf("Expected 'test error', got '%s'", errMsg.Error)
	}

	if errMsg.ID != "test-request" {
		t.Errorf("Expected ID to match request, got %s", errMsg.ID)
	}

	if errMsg.Target != "test-source" {
		t.Errorf("Expected target to be request source, got %s", errMsg.Target)
	}

	if errMsg.CorrelationID != "test-correlation" {
		t.Errorf("Expected correlation ID to match, got %s", errMsg.CorrelationID)
	}
}

func TestRPCGetCVE_EmptyCVEID(t *testing.T) {
	logger := common.NewLogger(os.Stderr, "test", common.InfoLevel)
	sp := subprocess.New("test")
	rpcClient := NewRPCClient(sp, logger)

	handler := createGetCVEHandler(rpcClient, logger)

	// Create request with empty CVE ID
	reqPayload, _ := sonic.Marshal(map[string]string{
		"cve_id": "",
	})
	msg := &subprocess.Message{
		Type:    subprocess.MessageTypeRequest,
		ID:      "RPCGetCVE",
		Payload: reqPayload,
	}

	ctx := context.Background()
	resp, err := handler(ctx, msg)

	if err != nil {
		t.Fatalf("Handler returned error: %v", err)
	}

	if resp.Type != subprocess.MessageTypeError {
		t.Errorf("Expected error type, got %s", resp.Type)
	}

	if resp.Error == "" {
		t.Error("Expected error message for empty CVE ID")
	}

	if resp.Error != "cve_id is required" {
		t.Errorf("Expected 'cve_id is required', got '%s'", resp.Error)
	}
}

func TestRPCGetCVE_InvalidPayload(t *testing.T) {
	logger := common.NewLogger(os.Stderr, "test", common.InfoLevel)
	sp := subprocess.New("test")
	rpcClient := NewRPCClient(sp, logger)

	handler := createGetCVEHandler(rpcClient, logger)

	// Create request with invalid JSON payload
	msg := &subprocess.Message{
		Type:    subprocess.MessageTypeRequest,
		ID:      "RPCGetCVE",
		Payload: []byte("invalid json"),
	}

	ctx := context.Background()
	resp, err := handler(ctx, msg)

	if err != nil {
		t.Fatalf("Handler returned error: %v", err)
	}

	if resp.Type != subprocess.MessageTypeError {
		t.Errorf("Expected error type, got %s", resp.Type)
	}

	if resp.Error == "" {
		t.Error("Expected error message for invalid payload")
	}
}

func TestRPCCreateCVE_EmptyCVEID(t *testing.T) {
	logger := common.NewLogger(os.Stderr, "test", common.InfoLevel)
	sp := subprocess.New("test")
	rpcClient := NewRPCClient(sp, logger)

	handler := createCreateCVEHandler(rpcClient, logger)

	// Create request with empty CVE ID
	reqPayload, _ := sonic.Marshal(map[string]string{
		"cve_id": "",
	})
	msg := &subprocess.Message{
		Type:    subprocess.MessageTypeRequest,
		ID:      "RPCCreateCVE",
		Payload: reqPayload,
	}

	ctx := context.Background()
	resp, err := handler(ctx, msg)

	if err != nil {
		t.Fatalf("Handler returned error: %v", err)
	}

	if resp.Type != subprocess.MessageTypeError {
		t.Errorf("Expected error type, got %s", resp.Type)
	}

	if resp.Error != "cve_id is required" {
		t.Errorf("Expected 'cve_id is required', got '%s'", resp.Error)
	}
}

func TestRPCUpdateCVE_EmptyCVEID(t *testing.T) {
	logger := common.NewLogger(os.Stderr, "test", common.InfoLevel)
	sp := subprocess.New("test")
	rpcClient := NewRPCClient(sp, logger)

	handler := createUpdateCVEHandler(rpcClient, logger)

	// Create request with empty CVE ID
	reqPayload, _ := sonic.Marshal(map[string]string{
		"cve_id": "",
	})
	msg := &subprocess.Message{
		Type:    subprocess.MessageTypeRequest,
		ID:      "RPCUpdateCVE",
		Payload: reqPayload,
	}

	ctx := context.Background()
	resp, err := handler(ctx, msg)

	if err != nil {
		t.Fatalf("Handler returned error: %v", err)
	}

	if resp.Type != subprocess.MessageTypeError {
		t.Errorf("Expected error type, got %s", resp.Type)
	}

	if resp.Error != "cve_id is required" {
		t.Errorf("Expected 'cve_id is required', got '%s'", resp.Error)
	}
}

func TestRPCDeleteCVE_EmptyCVEID(t *testing.T) {
	logger := common.NewLogger(os.Stderr, "test", common.InfoLevel)
	sp := subprocess.New("test")
	rpcClient := NewRPCClient(sp, logger)

	handler := createDeleteCVEHandler(rpcClient, logger)

	// Create request with empty CVE ID
	reqPayload, _ := sonic.Marshal(map[string]string{
		"cve_id": "",
	})
	msg := &subprocess.Message{
		Type:    subprocess.MessageTypeRequest,
		ID:      "RPCDeleteCVE",
		Payload: reqPayload,
	}

	ctx := context.Background()
	resp, err := handler(ctx, msg)

	if err != nil {
		t.Fatalf("Handler returned error: %v", err)
	}

	if resp.Type != subprocess.MessageTypeError {
		t.Errorf("Expected error type, got %s", resp.Type)
	}

	if resp.Error != "cve_id is required" {
		t.Errorf("Expected 'cve_id is required', got '%s'", resp.Error)
	}
}

func TestRPCListCVEs_DefaultParameters(t *testing.T) {
	logger := common.NewLogger(os.Stderr, "test", common.InfoLevel)
	sp := subprocess.New("test")
	rpcClient := NewRPCClient(sp, logger)

	handler := createListCVEsHandler(rpcClient, logger)

	// Create request with no payload (should use defaults)
	msg := &subprocess.Message{
		Type:    subprocess.MessageTypeRequest,
		ID:      "RPCListCVEs",
		Payload: nil,
	}

	// Use a context with short timeout since we expect this to fail
	ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
	defer cancel()

	// This will fail to connect to cve-local since it's not running,
	// but we're testing that the handler accepts nil payload
	resp, err := handler(ctx, msg)

	// The handler itself should not return a Go error
	if err != nil {
		t.Fatalf("Handler returned unexpected error: %v", err)
	}

	// It should return an error message about connection failure or timeout, not panic
	if resp == nil {
		t.Fatal("Handler returned nil response")
	}
}

func TestNewRPCClient(t *testing.T) {
	logger := common.NewLogger(os.Stderr, "test", common.InfoLevel)
	sp := subprocess.New("test-client")

	client := NewRPCClient(sp, logger)

	if client == nil {
		t.Fatal("NewRPCClient returned nil")
	}

	if client.sp != sp {
		t.Error("RPC client subprocess reference not set correctly")
	}

	if client.logger != logger {
		t.Error("RPC client logger reference not set correctly")
	}

	if client.pendingRequests == nil {
		t.Error("RPC client pendingRequests map not initialized")
	}
}

func TestRPCClient_HandleResponse(t *testing.T) {
	logger := common.NewLogger(os.Stderr, "test", common.InfoLevel)
	sp := subprocess.New("test-client")

	client := NewRPCClient(sp, logger)

	// Create a test message
	msg := &subprocess.Message{
		Type:          subprocess.MessageTypeResponse,
		ID:            "test",
		CorrelationID: "unknown-correlation",
	}

	ctx := context.Background()
	// Should not panic even with unknown correlation ID
	resp, err := client.handleResponse(ctx, msg)

	if err != nil {
		t.Errorf("handleResponse returned error: %v", err)
	}

	// Should return nil (no additional response needed)
	if resp != nil {
		t.Error("handleResponse should return nil response")
	}
}

func TestRPCClient_HandleError(t *testing.T) {
	logger := common.NewLogger(os.Stderr, "test", common.InfoLevel)
	sp := subprocess.New("test-client")

	client := NewRPCClient(sp, logger)

	// Create a test error message
	msg := &subprocess.Message{
		Type:          subprocess.MessageTypeError,
		ID:            "test",
		Error:         "test error",
		CorrelationID: "unknown-correlation",
	}

	ctx := context.Background()
	// Should not panic even with unknown correlation ID
	resp, err := client.handleError(ctx, msg)

	if err != nil {
		t.Errorf("handleError returned error: %v", err)
	}

	// Should return nil (no additional response needed)
	if resp != nil {
		t.Error("handleError should return nil response")
	}
}

// TestRPCSaveCVEByID_MissingCVE tests the error case when CVE field is missing
func TestRPCSaveCVEByID_MissingCVE(t *testing.T) {
	logger := common.NewLogger(os.Stderr, "test", common.InfoLevel)
	sp := subprocess.New("test")
	rpcClient := NewRPCClient(sp, logger)

	handler := createCreateCVEHandler(rpcClient, logger)

	// Create request with missing fields
	reqPayload, _ := sonic.Marshal(map[string]string{})
	msg := &subprocess.Message{
		Type:    subprocess.MessageTypeRequest,
		ID:      "RPCCreateCVE",
		Payload: reqPayload,
		Source:  "test",
	}

	ctx := context.Background()
	resp, err := handler(ctx, msg)

	if err != nil {
		t.Fatalf("Handler returned error: %v", err)
	}

	if resp.Type != subprocess.MessageTypeError {
		t.Errorf("Expected error type, got %s", resp.Type)
	}
}
